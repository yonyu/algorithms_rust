use std::cell::RefCell;
use std::rc::Rc;
use crate::linked_lists::linked_list_node::{Node, NodeLink};

#[derive(Debug)]
pub struct LinkedList<T> {
    pub head: NodeLink<T>,
    pub count: i32,
}

impl <T> LinkedList<T> {
    pub fn new() -> Self {
        LinkedList {
            head: None,
            count: 0,
        }
    }

    pub fn push_front(&mut self, value: T) {
        let new_node = Node::new(value);
        new_node.borrow_mut().next = self.head.take();

        self.head = Some(new_node);
        self.count += 1;
    }

    // return the value of the first node in the linked list without removing it
    pub fn peek(&self) -> Option<&T> {
        self.head.as_ref().map(|node| &node.borrow().value)
    }

    pub fn pop_front(&mut self) -> Option<T> {
        self.head.take().map(|node| {
            self.head = node.borrow_mut().next.take();
            self.count -= 1;
            Rc::try_unwrap(node).ok().unwrap().into_inner().value
        })
    }

    // return the value of the last node in the linked list without removing it
    pub fn peek_tail(&mut self) -> Option<T> {
        let mut current = &self.head;
        let mut previous = &mut self.head;

        while let Some(node) = current {
            if node.borrow().next.is_none() {
                previous.borrow_mut().next.take();
                self.count -= 1;
                return Some(Rc::try_unwrap(node).ok().unwrap().into_inner().value);
            }

            previous = &mut node.borrow_mut().next;
            current = &node.borrow().next;
        }

        None
    }

    // remove and return the value of the last node in the linked list
    pub fn pop_tail(&mut self) -> Option<T> {
        let mut current = &self.head;
        let mut previous = &mut self.head;

        while let Some(node) = current {
            if node.borrow().next.is_none() {
                previous.borrow_mut().next.take();
                self.count -= 1;
                return Some(Rc::try_unwrap(node).ok().unwrap().into_inner().value);
            }

            previous = &mut node.borrow_mut().next;
            current = &node.borrow().next;
        }

        None
    }

    // add a new node to the end of the linked list
    pub fn push(&mut self, value: T) { // O(n)
        let new_node = Node::new(value);
        let mut current = &mut self.head;

        while let Some(node) = current {
            if node.borrow().next.is_none() {
                node.borrow_mut().next = Some(new_node.clone());
                self.count += 1;
                return;
            }

            current = &mut node.borrow_mut().next;
        }
    }


    //fn push_back(&mut self, node: &mut NodeLink<T>, value: T) {
    //     //let new_node = Node::new(value);
    //     match node.take() {
    //         Some(x) => {
    //             let current = current.take();
    //             while current != None {
    //                 current = *current.next;
    //                 x.borrow_mut().next = Some(new_node.clone());
    //             }
    //
    //             self.count += 1;
    //         },
    //         None => {
    //             self.head = Some(Rc::new(RefCell::new(node)));
    //             self.count += 1;
    //         }
    //     }
    //}

    // pub fn add_node(&mut self, node: Node<T>) {
    //     match &self.head {
    //         Some(mut x) => {
    //             let new_node = Some(Rc::new(RefCell::new(node)));
    //             let current = &self.head.unwrap().borrow();
    //             while current != None {
    //                 current = *current.next;
    //                 x.next = new_node;
    //             }
    //
    //             self.count += 1;
    //         },
    //         None => {
    //             self.head = Some(Rc::new(RefCell::new(node)));
    //             self.count += 1;
    //         }
    //     }
    // }

}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_push_front() {
        let mut list = LinkedList::new();
        list.push_front(1);
        println!("{:?}", list)
    }

    #[test]
    fn test_push_back() {
        let mut list = LinkedList::new();
        list.push_front(1);
        list.push_front(2);
        println!("{:?}", list)
    }
}